# 보고서
2025.12.15

## 프로젝트 개요

본 프로젝트는 영어 공부에 도움이 되는 채팅 애플리케이션 서비스 프로토콜을 구현합니다. 사용자들이 서버를 통해 실시간으로 메시지를 주고받을 수 있으며, 다양한 통신 모드를 지원합니다. 영어 철자 검사 기능, 영어 단어 퀴즈, 영어 선생님 채팅방 서비스 등을 제공합니다.

## 주요 기능

1.  **클라이언트-서버 소켓 통신 :** 안정적인 TCP/IP 기반의 소켓 통신을 통해 클라이언트와 서버 간의 메시지 교환을 가능하게 합니다.
2.  **서버 브로드캐스트 통신:** 서버에 연결된 모든 클라이언트에게 메시지를 한 번에 전송하여 공지사항 전달이나 전체 채팅 기능을 제공합니다.
3.  **클라이언트 간 1:1 통신 (서버 중개):** 특정 클라이언트에게만 메시지를 전송하는 기능을 서버가 중개하여 프라이빗 메시징을 지원합니다.
4.  **클라이언트 그룹 통신:** 다수의 클라이언트를 그룹으로 묶어, 그룹 내에서만 메시지를 주고받을 수 있는 채팅방 기능을 제공합니다.
5.  **영어 철자 검사 기능:** 클라이언트가 전송하는 영어 메시지에 대해 서버 또는 클라이언트 측에서 철자 오류를 검사하고 수정 제안을 제공합니다.

## 사용자 흐름

본 채팅 애플리케이션의 일반적인 사용자 흐름은 다음과 같습니다.

1.  **애플리케이션 시작 및 서버 연결:**
    *   사용자는 클라이언트 애플리케이션을 실행합니다.
    *   클라이언트는 설정된 서버 주소와 포트를 통해 서버에 연결을 시도합니다.
    *   연결이 성공하면 사용자 이름(또는 ID)을 등록하거나 로그인합니다.

2.  **메시지 송수신:**
    1.  **전체 채팅 (브로드캐스트):** 사용자가 일반 메시지를 입력하여 전송하면, 서버는 이 메시지를 현재 접속 중인 모든 사용자에게 전달합니다.
    2.  **영어 단어 퀴즈 출제:** 사용자는 퀴즈를 출제하여 다른 모든 사용자에게 보낼 수 있습니다.
    3.  **퀴즈 정답 도전:** 다른 사용자가 낸 퀴즈에 대한 정답을 입력하여 모든 사용자에게 공유할 수 있습니다.
    4.  **1:1 개인 메시지:** 사용자는 특정 명령어(예: `/w <대상 사용자명> <메시지>`)를 사용하여 특정 대상 사용자에게만 메시지를 보낼 수 있습니다. 서버는 이 메시지를 해당 사용자에게만 중개합니다.
    5.  **그룹 채팅 (영어 선생님 채팅방 입장):** 사용자는 '영어 선생님 채팅방'에 입장하여 해당 그룹 내의 모든 참여자와 소통할 수 있습니다.

3.  **영어 철자 검사 피드백:**
    *   사용자가 영어 메시지를 전송할 때, 클라이언트 또는 서버는 해당 메시지의 철자 오류를 검사합니다.
    *   오류가 감지되면, 사용자에게 수정 제안이 제공되거나, 잘못된 단어가 표시되어 사용자가 직접 수정할 수 있도록 안내합니다.

4.  **연결 종료:**
    *   사용자가 클라이언트 애플리케이션을 종료하거나, 명시적인 종료 명령(예: `/exit` 또는 `/quit`)을 입력하면 서버와의 연결이 해제됩니다.
    *   비정상적인 연결 끊김(네트워크 오류 등)의 경우에도 서버는 해당 클라이언트의 연결을 안전하게 처리합니다.

## 1. 클라이언트와 서버 소켓 통신 - 맞춤법 검사

클라이언트와 서버 간의 소켓 통신은 일반적으로 **TCP/IP 프로토콜**을 기반으로 이루어집니다. 클라이언트가 서버에게 맞춤법 검사할 메시지를 보내면 서버는 맞춤법 검사기를 통해 철자 오류를 분석해서 수정된 문자를 반환합니다. 통신 과정은 다음과 같습니다.

*   **맞춤법 검사 요청**: `SPELL_CHECK :<text_to_check>`
*   **맞춤법 검사 결과**: `SPELL_RESULT :<corrected_text>`

**서버 측:**
1.  **소켓 생성 (`socket()`):** 통신을 위한 소켓을 생성합니다.
2.  **주소 할당 (`bind()`):** 생성된 소켓에 특정 IP 주소와 포트 번호를 할당합니다. 서버는 이 주소에서 클라이언트의 접속을 기다리게 됩니다.
3.  **연결 대기 (`listen()`):** 클라이언트의 연결 요청을 기다리는 상태로 전환합니다. 동시에 연결을 허용할 클라이언트의 수를 지정할 수 있습니다.
4.  **연결 수락 (`accept()`):** 클라이언트의 연결 요청이 오면 이를 수락하고, 데이터 통신을 위한 새로운 소켓을 생성하여 반환합니다. 기존의 리스닝 소켓은 다른 클라이언트의 연결을 계속 기다립니다.

**클라이언트 측:**
1.  **소켓 생성 (`socket()`):** 통신을 위한 소켓을 생성합니다.
2.  **연결 요청 (`connect()`):** 서버의 IP 주소와 포트 번호로 연결을 시도합니다.
3.  **연결 성공:** 서버가 `accept()`를 호출하면 연결이 성공적으로 수립됩니다.

연결이 수립된 후, 양측은 `send()` (데이터 전송)와 `recv()` (데이터 수신) 함수를 사용하여 메시지를 주고받을 수 있습니다.

## 2. 서버의 브로드캐스트 통신 - 영어 단어 퀴즈 & 퀴즈 정답 도전

서버가 여러 클라이언트에게 동일한 메시지를 한 번에 보내는 것을 브로드캐스트라고 합니다. 한 클라이언트가 퀴즈를 출제하면 모든 클라이언트에게 브로드캐스트됩니다. 다른 클라이언트가 출제한 퀴즈의 정답을 맞출 수 있으며, 입력한 정답은 모든 사용자에게 공유됩니다.

*   **퀴즈 출제**: `QUIZ :<question>`
*   **퀴즈 정답 도전**: `QUIZ_ANSWER :<answer>`
*   **일반 메시지 수신 (퀴즈, 1:1, 시스템 메시지 등)**: `MSG_RECV <from_id> :<message>`

**구현 방식:**
1.  **클라이언트 목록 관리:** 서버는 새로운 클라이언트가 연결될 때마다 해당 클라이언트의 소켓 객체를 리스트나 다른 자료구조에 저장합니다.
2.  **메시지 전파:** 특정 클라이언트로부터 메시지를 받거나 서버 자체에서 공지할 내용이 발생하면, 관리하고 있는 클라이언트 소켓 리스트를 순회하면서 각 소켓에 동일한 메시지를 `send()` 함수로 전송합니다.
3.  **연결 종료 처리:** 클라이언트의 연결이 끊어지면, 해당 클라이언트의 소켓을 리스트에서 반드시 제거하여 더 이상 메시지를 보내지 않도록 처리해야 합니다.

## 3. 클라이언트 간 통신 (서버 중개) - 1:1 채팅

클라이언트가 다른 특정 클라이언트에게 1:1 메시지(귓속말)를 보내는 기능은 서버를 통해 중개됩니다. 특정 사용자를 지정하여 개인적인 메시지를 주고받을 수 있습니다.

*   **1:1 메시지**: `P_MSG <target_user_id> :<message>`

**구현 방식:**
1.  **사용자 식별:** 서버는 각 클라이언트를 식별할 수 있는 고유한 정보(예: 사용자 이름, ID)를 소켓과 함께 관리해야 합니다. (예: `{'username': client_socket}`)
2.  **프로토콜 정의:** 메시지 형식에 대한 규칙(프로토콜)을 정의합니다. 예를 들어, 클라이언트는 `TO:<수신자ID> MSG:<메시지내용>`과 같은 형식으로 서버에 메시지를 보낼 수 있습니다.
3.  **메시지 중개:**
    *   서버는 메시지를 수신하면, `TO:` 부분을 파싱하여 수신자 ID를 확인합니다.
    *   관리하고 있는 사용자 목록에서 해당 ID의 클라이언트 소켓을 찾습니다.
    *   찾은 소켓으로 `MSG:` 부분의 메시지 내용을 전달합니다. 이 때, 누가 보냈는지 알려주기 위해 `FROM:<송신자ID> MSG:<메시지내용>` 형식으로 가공하여 보낼 수 있습니다.

## 4. 클라이언트 그룹 통신 - 영어 선생님 채팅방

채팅방 기능과 같이 여러 클라이언트를 그룹으로 묶어, 해당 그룹에 속한 클라이언트들끼리만 통신하는 기능입니다.'영어 선생님 채팅방'에 입장하여 해당 채팅방에 있는 모든 사람과 대화할 수 있습니다.

*   **채팅방 입장**: `JOIN_ROOM <room_name>`
*   **채팅방 퇴장**: `LEAVE_ROOM <room_name>`
*   **채팅방 메시지**: `ROOM_MSG <room_name> :<message>`
*   **채팅방 입장 성공**: `JOIN_SUCCESS <room_name> :<message>`
*   **채팅방 메시지 수신**: `ROOM_MSG_RECV <room_name> <from_id>`

**구현 방식:**
1.  **그룹 정보 관리:** 서버는 그룹 정보를 저장할 자료구조를 사용합니다. 예를 들어, 딕셔너리를 사용하여 각 그룹 이름에 해당 그룹에 속한 클라이언트 소켓들의 리스트를 저장할 수 있습니다. (예: `{'group_A': [socket1, socket3], 'group_B': [socket2, socket4]}`)
2.  **그룹 관리 기능:** 다음과 같은 기능을 위한 프로토콜을 정의해야 합니다.
    *   **그룹 생성:** `CREATE_GROUP:<그룹이름>`
    *   **그룹 참가:** `JOIN_GROUP:<그룹이름>`
    *   **그룹 탈퇴:** `LEAVE_GROUP:<그룹이름>`
3.  **그룹 메시지 전송:**
    *   클라이언트가 특정 그룹에 메시지를 보낼 때는 `GROUP_MSG:<그룹이름> MSG:<메시지내용>`과 같은 형식으로 서버에 전송합니다.
    *   서버는 메시지를 받으면 `<그룹이름>`을 확인하고, 관리하고 있는 그룹 정보에서 해당 그룹에 속한 모든 클라이언트 소켓을 찾습니다.
    *   찾아낸 소켓 리스트를 순회하며 각 클라이언트에게 메시지를 전달합니다.